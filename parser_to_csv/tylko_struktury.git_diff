diff --git a/parser_to_csv/src/main.cpp b/parser_to_csv/src/main.cpp
index 2a87960..99b6e17 100644
--- a/parser_to_csv/src/main.cpp
+++ b/parser_to_csv/src/main.cpp
@@ -123,6 +123,133 @@ std::unordered_map<std::string, double> deserialize_binary(const std::string& fi
     return map;
 }
 
+
+
+struct Multi_Tree_Node
+{
+    Multi_Tree_Node* parent;
+    vector<Multi_Tree_Node*> children;
+    string id;
+    double value;
+
+    Multi_Tree_Node(Multi_Tree_Node* p, string i, double v)
+        :parent(p)
+        ,id(i)
+        ,value(v)
+    {
+    }
+};
+
+class Tree
+{
+    Multi_Tree_Node* top;
+
+    vector<string> params_to_strings(tupl all_params)
+    {
+        auto& [adding_read] = all_params;
+
+        vector<string> all_params_in_order;
+        all_params_in_order.push_back(read_processor);
+        all_params_in_order.push_back(read_model);
+        all_params_in_order.push_back(read_arch);
+        all_params_in_order.push_back(read_unit);
+        all_params_in_order.push_back(read_physical_cores);
+        all_params_in_order.push_back(read_logical_cores);
+        all_params_in_order.push_back(read_core_proportion);
+
+        #ifdef MAIN
+            all_params_in_order.push_back(read_scene);
+            all_params_in_order.push_back(read_lights);
+            all_params_in_order.push_back(read_spheres);
+            all_params_in_order.push_back(read_bounces);
+        #endif
+        #ifdef SINGLE
+            all_params_in_order.push_back(read_task);
+            all_params_in_order.push_back(read_size);
+        #endif
+
+        all_params_in_order.push_back(read_num_of_threads);
+        all_params_in_order.push_back(read_rating);
+
+        return all_params_in_order;
+    }
+    void add_one_value_IMP(Multi_Tree_Node* current_node, const vector<string>& all_params_in_order, u64 param_index, const double& value)
+    {
+        bool last_one = (param_index == all_params_in_order.size() - 1);
+        const string current_id = all_params_in_order[param_index];
+
+        if(!last_one)
+        {
+            for(auto& child : current_node->children)
+            {
+                if(child->id == current_id)
+                {
+                    add_one_value_IMP(child, all_params_in_order, param_index + 1, value);
+                    return;
+                }
+            }
+
+            // nowy Node - pośredni
+            Multi_Tree_Node* new_node = new Multi_Tree_Node(current_node, current_id, INVALID_VALUE); // node pośredni -> nie koniec
+            current_node->children.push_back(new_node); // dodanie do dzieci parenta
+            add_one_value_IMP(new_node, all_params_in_order, param_index + 1, value);
+        }
+        else
+        {
+            // nowy Node - ostatni
+            Multi_Tree_Node* new_node = new Multi_Tree_Node(current_node, current_id, value); // podpięcie do parenta i ustawienie current id i value
+            current_node->children.push_back(new_node); // dodanie do dzieci parenta
+        }
+    }
+    double get_value_IMP(Multi_Tree_Node* current_node, const vector<string>& all_params_in_order, u64 param_index)
+    {
+        bool last_one = (param_index == all_params_in_order.size());
+
+        if(last_one)
+        {
+            return current_node->value;
+        }
+        else
+        {
+            const string current_id = all_params_in_order[param_index];
+
+            for(auto& child : current_node->children)
+            {
+                if(child->id == current_id)
+                {
+                    return get_value_IMP(child, all_params_in_order, param_index + 1);
+                }
+            }
+        }
+
+        return INVALID_VALUE;
+    }
+
+public:
+
+    Tree()
+    {
+        top = new Multi_Tree_Node(nullptr, "", INVALID_VALUE);
+    }
+
+    double get(tupl all_params)
+    {
+        vector<string> all_params_in_order = params_to_strings(all_params);
+
+        return get_value_IMP(top, all_params_in_order, 0);
+    }
+    void add(tupl all_params, double value)
+    {
+        vector<string> all_params_in_order = params_to_strings(all_params);
+
+        add_one_value_IMP(top, all_params_in_order, 0, value);
+    }
+};
+
+vector<Tree*> all_trees; // każdy plik po prostu tworzy swoje drzewo i dodaje pointer do niego tutaj -> tworzy z new i nie zwalnia
+
+
+
 class All_Category_Combinations
 {
     string input_dir;
